// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: bsky.ipynb

import { BskyXRPC } from "@mary/bluesky-client";
import type {
  AppBskyEmbedExternal,
  AppBskyEmbedImages,
  AppBskyFeedDefs,
  AppBskyFeedPost,
} from "@mary/bluesky-client/lexicons";

type Thread = AppBskyFeedDefs.ThreadViewPost;
type Post = AppBskyFeedDefs.PostView;
type PostRecord = AppBskyFeedPost.Record;
type EmbedImages = AppBskyEmbedImages.View;
type EmbedExternal = AppBskyEmbedExternal.View;

const rpc = new BskyXRPC({ service: "https://public.api.bsky.app" });
const postURLToAtpURI = async (
  postUrl: string,
): Promise<[string, string]> => {
  const urlParts = new URL(postUrl);
  const pathParts = urlParts.pathname.split("/");
  const h = await rpc.get("com.atproto.identity.resolveHandle", {
    params: {
      handle: pathParts[2],
    },
  });

  return [`at://${h.data.did}/app.bsky.feed.post/${pathParts[4]}`, h.data.did];
};
const unwrapThreadPosts = (
  thread: Thread,
): Post[] => {
  const posts: Post[] = [];

  // Add root post
  if (thread.post) {
    posts.push(thread.post);
  }

  // Recursively handle replies
  if (thread.replies) {
    thread.replies.forEach((reply) => {
      posts.push(...unwrapThreadPosts(reply as Thread));
    });
  }

  // Handle nested reply if present
  if ("parent" in thread && thread.parent) {
    posts.push(
      ...unwrapThreadPosts(thread.parent as Thread),
    );
  }

  return posts;
};

type ThreadData = {
  handle: string;
  posts: Post[];
};

export const downloadThread = async (
  postUrl: string,
): Promise<ThreadData> => {
  const [uri, handle] = await postURLToAtpURI(postUrl);
  const d = await rpc.get("app.bsky.feed.getPostThread", {
    params: {
      uri,
    },
  });
  const r = unwrapThreadPosts(d.data.thread as Thread);
  return {
    handle,
    posts: r.sort(
      (a: Post, b: Post) =>
        new Date((a.record as PostRecord).createdAt).getTime() -
        new Date((b.record as PostRecord).createdAt).getTime(),
    ),
  };
};
// from https://github.com/mary-ext/skeetdeck/blob/aa0cb74c0ace489b79d2671c4b9e740ec21623c7/app/api/richtext/unicode.ts

const encoder = new TextEncoder();
const decoder = new TextDecoder();

interface UtfString {
  u16: string;
  u8: Uint8Array;
}

const createUtfString = (utf16: string): UtfString => {
  return {
    u16: utf16,
    u8: encoder.encode(utf16),
  };
};

// const getUtf8Length = (utf: UtfString) => {
// 	return utf.u8.byteLength;
// };

const sliceUtf8 = (utf: UtfString, start?: number, end?: number) => {
  return decoder.decode(utf.u8.slice(start, end));
};
const externalEmbedToMarkdown = (
  embed: EmbedExternal,
  authorDid: string,
): string => {
  const { title, description, uri, thumb } = embed.external;

  console.log(embed);

  let thumbUrl: string | undefined;

  if (typeof thumb === "string") {
    thumbUrl = thumb;
  } else if (thumb) {
    thumbUrl =
      // @ts-ignore not sure why this is failing
      `https://cdn.bsky.app/img/feed_thumbnail/plain/${authorDid}/${thumb.ref.$link}@jpeg`;
  }

  const thumbImage = thumbUrl ? `![${title}](${thumbUrl})` : null;

  return [`### [${title}](${uri})`, description, thumbImage || ""]
    .map((l: string) => `> ${l}`)
    .join("\n");
};

// await (async () => {
//   const { posts, handle } = await downloadThread(
//       "https://bsky.app/profile/jason.energy/post/3ldllxneijk2d"
//     );

//   return Deno.jupyter.display(
//     {
//       "text/markdown": externalEmbedToMarkdown(
//         posts[0].record.embed as EmbedExternal,
//         handle
//       ),
//     },
//     { raw: true }
//   );
// })();
export const postToMd = (post: Post, handle: string): string => {
  const record = post.record as PostRecord;
  const text = record.text;
  let richtext = text;
  let embeds = "";

  console.log(record);

  if (record.facets) {
    for (const facet of record.facets) {
      for (const feature of facet.features) {
        if (feature.$type === "app.bsky.richtext.facet#link") {
          const linkPlaceholder = sliceUtf8(
            createUtfString(text),
            facet.index.byteStart,
            facet.index.byteEnd,
          );
          richtext = richtext.replace(
            linkPlaceholder,
            `[${linkPlaceholder}](${feature.uri})`,
          );
        } else if (feature.$type === "app.bsky.richtext.facet#mention") {
          const mentionPlaceholder = sliceUtf8(
            createUtfString(text),
            facet.index.byteStart,
            facet.index.byteEnd,
          );
          richtext = richtext.replace(
            mentionPlaceholder,
            `[${mentionPlaceholder}](https://bsky.app/profile/${feature.did})`,
          );
        }
      }
    }
  }

  if (post.embed) {
    if (post.embed.$type === "app.bsky.embed.images#view") {
      const e = post.embed as EmbedImages;
      for (const image of e.images) {
        embeds += `![${
          image.alt || "no image description"
        }](${image.fullsize})\n`;
      }
    } else if (post.embed.$type === "app.bsky.embed.external#view") {
      embeds += externalEmbedToMarkdown(
        post.embed as EmbedExternal,
        handle,
      );
    }
  }

  const [d, t] = record.createdAt.split("T");
  const [h, m] = t.split(":");

  return [
    `> [${post.author.displayName} - @${post.author.handle}](https://bsky.app/profile/${post.author.handle}) **${d} ${
      [h, m].join(
        ":",
      )
    }**`,
    ...richtext.split("\n").filter((l: string) => l.trim() !== ""),
    embeds,
  ].join("\n\n");
};

// await Deno.jupyter.display(
//   {
//     "text/markdown": postToMd(posts[0], handle),
//   },
//   { raw: true }
// );
export const downloadPostToMd = async (postUrl: string): Promise<string> => {
  const { posts, handle } = await downloadThread(postUrl);

  return posts.map((post) => postToMd(post, handle)).join("\n\n");
};
