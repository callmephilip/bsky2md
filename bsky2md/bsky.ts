// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: bsky.ipynb

import { BskyXRPC } from "@mary/bluesky-client";
import type {
  AppBskyFeedDefs,
  AppBskyFeedPost,
} from "@mary/bluesky-client/lexicons";

type Thread = AppBskyFeedDefs.ThreadViewPost;
type Post = AppBskyFeedDefs.PostView;
type PostRecord = AppBskyFeedPost.Record;

const rpc = new BskyXRPC({ service: "https://public.api.bsky.app" });
const postURLToAtpURI = async (
  postUrl: string,
): Promise<string> => {
  const urlParts = new URL(postUrl);
  const pathParts = urlParts.pathname.split("/");
  const h = await rpc.get("com.atproto.identity.resolveHandle", {
    params: {
      handle: pathParts[2],
    },
  });

  return `at://${h.data.did}/app.bsky.feed.post/${pathParts[4]}`;
};
const unwrapThreadPosts = (
  thread: Thread,
): Post[] => {
  const posts: Post[] = [];

  // Add root post
  if (thread.post) {
    posts.push(thread.post);
  }

  // Recursively handle replies
  if (thread.replies) {
    thread.replies.forEach((reply) => {
      posts.push(...unwrapThreadPosts(reply as Thread));
    });
  }

  // Handle nested reply if present
  if ("parent" in thread && thread.parent) {
    posts.push(
      ...unwrapThreadPosts(thread.parent as Thread),
    );
  }

  return posts;
};

export const downloadThread = async (
  postUrl: string,
) => {
  const d = await rpc.get("app.bsky.feed.getPostThread", {
    params: {
      uri: await postURLToAtpURI(postUrl),
    },
  });
  const r = unwrapThreadPosts(d.data.thread as Thread);
  return r.sort(
    (a: Post, b: Post) =>
      new Date((a.record as PostRecord).createdAt).getTime() -
      new Date((b.record as PostRecord).createdAt).getTime(),
  );
};
export const postToMd = (post: Post): string => {
  // console.log(">>>>>>> working on", post);

  const record = post.record as PostRecord;
  const text = record.text;
  let richtext = text;

  if (record.facets) {
    for (const facet of record.facets) {
      for (const feature of facet.features) {
        if (feature.$type === "app.bsky.richtext.facet#link") {
          const linkPlaceholder = text.slice(
            facet.index.byteStart,
            facet.index.byteEnd,
          );
          richtext = richtext.replace(
            linkPlaceholder,
            `[${linkPlaceholder}](${feature.uri})`,
          );
        }
      }
    }
  }

  return `
    # ${post.author.displayName} (@${post.author.handle}) - ${record.createdAt}

    ${richtext}
  `;
};

// await Deno.jupyter.display(
//   {
//     "text/markdown": postToMd(posts[1]),
//   },
//   { raw: true }
// );
export const downloadPostToMd = async (postUrl: string): Promise<string> => {
  const posts = await downloadThread(postUrl);

  return posts.reduce((acc, post) => {
    return acc + postToMd(post);
  }, "");
};
