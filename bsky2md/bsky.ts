// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: bsky.ipynb

import { BskyXRPC } from "@mary/bluesky-client";
import type {
  AppBskyEmbedImages,
  AppBskyFeedDefs,
  AppBskyFeedPost,
} from "@mary/bluesky-client/lexicons";

type Thread = AppBskyFeedDefs.ThreadViewPost;
type Post = AppBskyFeedDefs.PostView;
type PostRecord = AppBskyFeedPost.Record;
type EmbedImages = AppBskyEmbedImages.View;

const rpc = new BskyXRPC({ service: "https://public.api.bsky.app" });
const postURLToAtpURI = async (
  postUrl: string,
): Promise<string> => {
  const urlParts = new URL(postUrl);
  const pathParts = urlParts.pathname.split("/");
  const h = await rpc.get("com.atproto.identity.resolveHandle", {
    params: {
      handle: pathParts[2],
    },
  });

  return `at://${h.data.did}/app.bsky.feed.post/${pathParts[4]}`;
};
const unwrapThreadPosts = (
  thread: Thread,
): Post[] => {
  const posts: Post[] = [];

  // Add root post
  if (thread.post) {
    posts.push(thread.post);
  }

  // Recursively handle replies
  if (thread.replies) {
    thread.replies.forEach((reply) => {
      posts.push(...unwrapThreadPosts(reply as Thread));
    });
  }

  // Handle nested reply if present
  if ("parent" in thread && thread.parent) {
    posts.push(
      ...unwrapThreadPosts(thread.parent as Thread),
    );
  }

  return posts;
};

export const downloadThread = async (
  postUrl: string,
) => {
  const d = await rpc.get("app.bsky.feed.getPostThread", {
    params: {
      uri: await postURLToAtpURI(postUrl),
    },
  });
  const r = unwrapThreadPosts(d.data.thread as Thread);
  return r.sort(
    (a: Post, b: Post) =>
      new Date((a.record as PostRecord).createdAt).getTime() -
      new Date((b.record as PostRecord).createdAt).getTime(),
  );
};
// from https://github.com/mary-ext/skeetdeck/blob/aa0cb74c0ace489b79d2671c4b9e740ec21623c7/app/api/richtext/unicode.ts

const encoder = new TextEncoder();
const decoder = new TextDecoder();

interface UtfString {
  u16: string;
  u8: Uint8Array;
}

const createUtfString = (utf16: string): UtfString => {
  return {
    u16: utf16,
    u8: encoder.encode(utf16),
  };
};

// const getUtf8Length = (utf: UtfString) => {
// 	return utf.u8.byteLength;
// };

const sliceUtf8 = (utf: UtfString, start?: number, end?: number) => {
  return decoder.decode(utf.u8.slice(start, end));
};
export const postToMd = (post: Post): string => {
  const record = post.record as PostRecord;
  const text = record.text;
  let richtext = text;
  let embeds = "";

  console.log(">>>>>>>>>>> text is", text);

  if (record.facets) {
    for (const facet of record.facets) {
      for (const feature of facet.features) {
        if (feature.$type === "app.bsky.richtext.facet#link") {
          const linkPlaceholder = sliceUtf8(
            createUtfString(text),
            facet.index.byteStart,
            facet.index.byteEnd,
          );
          richtext = richtext.replace(
            linkPlaceholder,
            `[${linkPlaceholder}](${feature.uri})`,
          );
        }
      }
    }
  }

  if (post.embed && post.embed.$type === "app.bsky.embed.images#view") {
    const e = post.embed as EmbedImages;
    for (const image of e.images) {
      embeds += `![${
        image.alt || "no image description"
      }](${image.fullsize})\n`;
    }
  }

  const [d, t] = record.createdAt.split("T");
  const [h, m] = t.split(":");

  console.log(">>>>", "lines", richtext.split("\n"));

  return [
    `> [${post.author.displayName} - @${post.author.handle}](https://bsky.app/profile/${post.author.handle}) **${d} ${
      [h, m].join(
        ":",
      )
    }**`,
    ...richtext.split("\n").filter((l: string) => l.trim() !== ""),
    embeds,
  ].join("\n\n");
};

// await Deno.jupyter.display(
//   {
//     "text/markdown": postToMd(posts[1]),
//   },
//   { raw: true }
// );
export const downloadPostToMd = async (postUrl: string): Promise<string> => {
  const posts = await downloadThread(postUrl);

  return posts.map((post) => postToMd(post)).join("\n\n");
};
